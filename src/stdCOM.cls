VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "stdCOM"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True

'@module
'@description A class which wraps a COM object. All objects in VBA are COM objects, and this class allows 
'you to access low level COM functionality. As such this class is recommended only to advanced users.
'@example ```vb
''Print all methods of the Application object
'Dim app ase stdCOM: set app = stdCOM.create(Application)
'Dim member
'For each member in app.Methods
'  Debug.Print member("name")
'next
'```
'@example ```vb
''Bind all methods of a class to a stdLambda object as stdCallbacks
'Public Function CreateBoundLambda(ByVal expression as string) as stdLambda
'  'Create lambda from expression string
'  set CreateBoundLambda = stdLambda.Create(expression)
'
'  'Loop over all methods and bind to lambda
'  Dim refl as stdCOM: set refl = stdCOM.Create(Me)
'  Dim method: For each method in refl.Methods
'    Dim cb as stdCallback: set cb = stdCallback.CreateFromObjectMethod(Me, method("name"))
'    Call CreateBoundLambda.BindGlobal(method("name"), cb)
'  next
'End Function
'```
'@example Setting the `track id` of a mp3 file:
'```vb
'Dim file as string: file = "C:\Users\sancarn\Music\HelloThere - Copy (2).mp3"
'Dim mp3 As stdCOM: Set mp3 = stdCOM.CreatePropertyStoreFromFile(file)
'Const PKEY_TrackFormatID As String = "{56A3372E-CE9C-11D2-9F0E-006097C686F6}"
'Const PKEY_TrackPropID as Long = 7
'Call mp3.PropertyStore_SetValue(PKEY_TrackFormatID, PKEY_TrackPropID, 1)
'Call mp3.PropertyStore_Commit()
'```
'@example Show an indefinitely scrolling progress bar for an Application
'```vb
'Private Enum EITaskbarList3
'    SetProgressValue = 9
'    SetProgressState = 10
'    SetOverlayIcon = 11
'End Enum
'Enum TBPF
'    TBPF_NOPROGRESS = &H0      ' Stops displaying progress.
'    TBPF_INDETERMINATE = &H1   ' Marquee-style progress.
'    TBPF_NORMAL = &H2          ' Normal determinate progress.
'    TBPF_ERROR = &H4           ' Red progress bar, indicating an error.
'    TBPF_PAUSED = &H8          ' Yellow progress bar, indicating paused state.
'End Enum
'
''Run this sub to make the excel task bar icon scroll indefinitely. Then click play again to stop it.
'Sub Main()
'  Const CLSID_TaskbarList As String = "{56FDF344-FD6D-11d0-958A-006097C9A090}"
'  Const IID_ITaskbarList3 As String = "{ea1afb91-9e28-4b86-90e9-9e9f8a5eefaf}"
'  Dim TaskbarList As stdCOM: Set TaskbarList = stdCOM.CreateFromClassAndIID(CLSID_TaskbarList, IID_ITaskbarList3)
'  If Not TaskbarList Is Nothing Then
'    Call TaskbarList.CallVT(EITaskbarList3.SetProgressState, vbLong, Application.hwnd, TBPF_INDETERMINATE)
'    
'    Stop
'
'    Call TaskbarList.CallVT(EITaskbarList3.SetProgressState, vbLong, Application.hwnd, TBPF_NOPROGRESS)
'  End If
'End Sub
'```



'TODO: Analyse and add anything missing from:
' * https://referencesource.microsoft.com/#system.data/fx/src/data/System/Data/OleDb/OLEDB_Util.cs,4254532afac0bd58,references
#If Win64 Then
  Private Const NULL_PTR As LongLong = 0^
#Else
  Private Const NULL_PTR As Long = 0&
#End If

#If VBA7 Then
    Private Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal Length As LongPtr)
    Private Declare PtrSafe Sub ZeroMemory Lib "kernel32" Alias "RtlZeroMemory" (Destination As Any, ByVal Length As Long)
    Private Declare PtrSafe Function DispCallFunc Lib "oleAut32.dll" (ByVal pvInstance As LongPtr, ByVal offsetinVft As LongPtr, ByVal CallConv As Long, ByVal retTYP As Integer, ByVal paCNT As Long, ByVal paTypes As LongPtr, ByVal paValues As LongPtr, ByRef retVAR As Variant) As Long
    Private Declare PtrSafe Sub SetLastError Lib "kernel32.dll" (ByVal dwErrCode As Long)
    Private Declare PtrSafe Function IIDFromString Lib "ole32.dll" (ByVal pstCLS As LongPtr, ByRef iid As GUID) As Long
    Private Declare PtrSafe Function CLSIDFromString Lib "ole32.dll" (ByVal pstCLS As LongPtr, ByRef iid As GUID) As Long
    
    'Iterate the ROT
    Private Declare PtrSafe Function GetRunningObjectTable Lib "ole32.dll" (ByVal dwReserved As Long, pROT As LongPtr) As Long
    Private Declare PtrSafe Function CreateBindCtx Lib "ole32.dll" (ByVal dwReserved As Long, pBindCtx As LongPtr) As Long
    Private Declare PtrSafe Function SysReAllocString Lib "oleAut32.dll" (ByVal pBSTR As LongPtr, Optional ByVal pszStrPtr As LongPtr) As Long
    Private Declare PtrSafe Function ProgIDFromCLSID Lib "ole32.dll" (ByRef rclsid As GUID, ByVal ProgID As LongPtr) As Long

    'Register to ROT
    Private Declare PtrSafe Function RegisterActiveObject32 Lib "oleAut32.dll" Alias "RegisterActiveObject" (ByVal pUnk As IUnknown, ByRef rclsid As GUID, ByVal dwFlags As Long, ByRef pdwRegister As Long) As Long
    Private Declare PtrSafe Function RevokeActiveObject32 Lib "oleAut32.dll" Alias "RevokeActiveObject" (ByVal dwRegister As Long, ByVal pvReserved As LongPtr) As Long
    Private Declare PtrSafe Function CoDisconnectObject Lib "ole32.dll" (ByVal pUnk As IUnknown, ByRef pvReserved As Long) As Long
    Private Declare PtrSafe Function CLSIDFromProgID Lib "ole32.dll" (ByVal ProgID As LongPtr, ByRef rclsid As GUID) As Long
    Private Declare PtrSafe Function CoCreateInstance Lib "ole32.dll" (ByRef rclsid As GUID, ByVal pUnkOuter As LongPtr, ByVal dwClsContext As Long, ByRef riid As GUID, ByRef ppv As LongPtr) As Long

    'WinRT
    Private Declare PtrSafe Function WindowsCreateString Lib "Combase.dll" (ByVal sourceString As LongPtr, ByVal Length As Long, ByRef hString As LongPtr) As Long
    Private Declare PtrSafe Function WindowsDeleteString Lib "Combase.dll" (ByVal sourceString As LongPtr) As Long
    Private Declare PtrSafe Function RoGetActivationFactory Lib "Combase.dll" (ByVal activatableClassId As LongPtr, ByRef riid As GUID, ByRef factory As Long) As Long
    Private Declare PtrSafe Function RoActivateInstance Lib "Combase.dll" (ByVal activatableClassId As LongPtr, ByRef instance As LongPtr) As Long

    'PropertyStore
    Private Declare PtrSafe Function SHGetPropertyStoreFromParsingName Lib "shell32" (ByVal pszPath As LongPtr, pbc As Any, ByVal Flags As Long, riid As GUID, ppv As Any) As Long

#Else
    Private Enum LongPtr
      [_]
    End Enum
    Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal Length As Long)
    Private Declare Sub ZeroMemory Lib "kernel32" Alias "RtlZeroMemory" (Destination As Any, ByVal Length As Long)
    'FIX: The use of `VbVarType` for the type of `paTypes` on 32 bit causes Invalid Callee error. Workaround is to use `Integer` instead as below.
    Private Declare Function DispCallFunc Lib "oleAut32.dll" (ByVal pvInstance As LongPtr, ByVal offsetinVft As LongPtr, ByVal CallConv As Long, ByVal retTYP As Integer, ByVal paCNT As Long, ByVal paTypes As LongPtr, ByVal paValues As LongPtr, ByRef retVAR As Variant) As Long
    Private Declare Sub SetLastError Lib "kernel32.dll" (ByVal dwErrCode As Long)
    Private Declare Function IIDFromString Lib "ole32.dll" (ByVal pstCLS As LongPtr, ByRef iid As GUID) As Long
    Private Declare Function CLSIDFromString Lib "ole32.dll" (ByVal pstCLS As LongPtr, ByRef iid As GUID) As Long
    
    'Iterate the ROT
    Private Declare Function GetRunningObjectTable Lib "ole32.dll" (ByVal dwReserved As Long, pROT As LongPtr) As Long
    Private Declare Function CreateBindCtx Lib "ole32.dll" (ByVal dwReserved As Long, pBindCtx As LongPtr) As Long
    Private Declare Function SysReAllocString Lib "oleAut32.dll" (ByVal pBSTR As LongPtr, Optional ByVal pszStrPtr As LongPtr) As Long
    Private Declare Function ProgIDFromCLSID Lib "ole32.dll" (ByRef rclsid As GUID, ByVal ProgID as LongPtr) as Long

    'Register to ROT
    Private Declare Function RegisterActiveObject32 Lib "oleAut32.dll" Alias "RegisterActiveObject" (ByVal pUnk As IUnknown, ByRef rclsid As GUID, ByVal dwFlags As Long, ByRef pdwRegister As Long) As Long
    Private Declare Function RevokeActiveObject32 Lib "oleAut32.dll" Alias "RevokeActiveObject" (ByVal dwRegister As Long, ByVal pvReserved As Long) As Long
    Private Declare Function CoDisconnectObject Lib "ole32.dll" (ByVal pUnk As IUnknown, ByRef pvReserved As Long) As Long
    Private Declare Function CLSIDFromProgID Lib "ole32.dll" (ByVal ProgID As Long, ByRef rclsid As GUID) As Long
    Private Declare Function CoCreateInstance Lib "ole32.dll" (ByRef rclsid As GUID, ByVal pUnkOuter As LongPtr, ByVal dwClsContext As Long, ByRef riid As GUID, ByRef ppv As LongPtr) As Long

    'WinRT
    Private Declare Function WindowsCreateString Lib "Combase.dll" (ByVal sourceString As LongPtr, ByVal Length As Long, ByRef hString As LongPtr) As Long
    Private Declare Function WindowsDeleteString Lib "Combase.dll" (ByVal sourceString As LongPtr) As Long
    Private Declare Function RoGetActivationFactory Lib "Combase.dll" (ByVal activatableClassId As LongPtr, ByRef riid As GUID, ByRef factory As Long) As Long
    Private Declare Function RoActivateInstance Lib "Combase.dll" (ByVal activatableClassId As LongPtr, ByRef instance As LongPtr) As Long

    'PropertyStore
    Private Declare Function SHGetPropertyStoreFromParsingName Lib "shell32" (ByVal pszPath As LongPtr, pbc As Any, ByVal Flags As Long, riid As GUID, ppv As Any) As Long
#End If

'GUID struct for QueryInterface
Private Type GUID
    Data1 As Long
    Data2 As Integer
    Data3 As Integer
    Data4(0 To 7) As Byte
End Type

'Used for IPropertyStore
Private Type PropertyKey
  formatID As GUID
  propID As Long
End Type

Private Type TTYPEDESC
    #If Win64 Then
        pTypeDesc As LongLong
    #Else
        pTypeDesc As Long
    #End If
    vt            As Integer
End Type

Private Type TPARAMDESC
    #If Win64 Then
        pPARAMDESCEX  As LongLong
    #Else
        pPARAMDESCEX  As Long
    #End If
    wParamFlags       As Integer
End Type


Private Type TELEMDESC
    tdesc  As TTYPEDESC
    pdesc  As TPARAMDESC
End Type

Private Type TYPEATTR
        aGUID As GUID
        LCID As Long
        dwReserved As Long
        memidConstructor As Long
        memidDestructor As Long
        #If Win64 Then
            lpstrSchema As LongLong
        #Else
            lpstrSchema As Long
        #End If
        cbSizeInstance As Integer
        typekind As Long
        cFuncs As Integer
        cVars As Integer
        cImplTypes As Integer
        cbSizeVft As Integer
        cbAlignment As Integer
        wTypeFlags As Integer
        wMajorVerNum As Integer
        wMinorVerNum As Integer
        tdescAlias As Long
        idldescType As Long
End Type


Private Type FUNCDESC
    memid As Long                  'The function member ID (DispId).
    #If Win64 Then
        lprgscode As LongLong         'Pointer to status code
        lprgelemdescParam As LongLong 'Pointer to description of the element.
    #Else
        lprgscode As Long             'Pointer to status code
        lprgelemdescParam As Long     'Pointer to description of the element.
    #End If
    funckind As Long                 'virtual, static, or dispatch-only
    INVOKEKIND As Long               'VbMethod / VbGet / VbSet / VbLet
    CallConv As Long                 'typically will be stdecl
    cParams As Integer               'number of parameters
    cParamsOpt As Integer            'number of optional parameters
    oVft As Integer                  'For FUNC_VIRTUAL, specifies the offset in the VTBL.
    cScodes As Integer               'The number of possible return values.
    elemdescFunc As TELEMDESC        'The function return type
    wFuncFlags As Integer            'The function flags. See FUNCFLAGS.
End Type


'Many interfaces are stored [here](http://cbotton.com/pictures/net/ole2.reg)
'not sure if they are useful.
'Not all of these IIDs will be useful. But hopefully some will be.
Public Enum EKnownInterfaces
  IUnknown                '00000000-0000-0000-C000-000000000046
  IDispatch               '00020400-0000-0000-C000-000000000046
  ITypeInfo               '00020401-0000-0000-C000-000000000046
  ITypeLib                '00020402-0000-0000-C000-000000000046
  ITypeComp               '00020403-0000-0000-C000-000000000046
  IEnumVARIANT            '00020404-0000-0000-C000-000000000046
  ICreateTypeInfo         '00020405-0000-0000-C000-000000000046
  ICreateTypeLib          '00020406-0000-0000-C000-000000000046
  IClassFactory           '00000001-0000-0000-C000-000000000046
  IMalloc                 '00000002-0000-0000-C000-000000000046
  IMarshal                '00000003-0000-0000-C000-000000000046
  IRpcChannel             '00000004-0000-0000-C000-000000000046
  IRpcStub                '00000005-0000-0000-C000-000000000046
  IRpcProxy               '00000007-0000-0000-C000-000000000046
  IPSFactory              '00000009-0000-0000-C000-000000000046
  ILockBytes              '0000000A-0000-0000-C000-000000000046
  IStorage                '0000000B-0000-0000-C000-000000000046
  IStream                 '0000000C-0000-0000-C000-000000000046
  IEnumSTATSTG            '0000000D-0000-0000-C000-000000000046
  IBindCtx                '0000000E-0000-0000-C000-000000000046
  IMoniker                '0000000F-0000-0000-C000-000000000046
  IRunningObjectTable     '00000010-0000-0000-C000-000000000046
  IRootStorage            '00000012-0000-0000-C000-000000000046
  IMessageFilter          '00000016-0000-0000-C000-000000000046
  IStdMarshalInfo         '00000018-0000-0000-C000-000000000046
  IExternalConnection     '00000019-0000-0000-C000-000000000046
  IEnumUnknown            '00000100-0000-0000-C000-000000000046
  IEnumString             '00000101-0000-0000-C000-000000000046
  IEnumMoniker            '00000102-0000-0000-C000-000000000046
  IEnumFORMATETC          '00000103-0000-0000-C000-000000000046
  IEnumOLEVERB            '00000104-0000-0000-C000-000000000046
  IEnumSTATDATA           '00000105-0000-0000-C000-000000000046
  IPersistStream          '00000109-0000-0000-C000-000000000046
  IPersistStorage         '0000010A-0000-0000-C000-000000000046
  IPersistFile            '0000010B-0000-0000-C000-000000000046
  IPersist                '0000010C-0000-0000-C000-000000000046
  IViewObject             '0000010D-0000-0000-C000-000000000046
  IDataObject             '0000010E-0000-0000-C000-000000000046
  IAdviseSink             '0000010F-0000-0000-C000-000000000046
  IDataAdviseHolder       '00000110-0000-0000-C000-000000000046
  IOleAdviseHolder        '00000111-0000-0000-C000-000000000046
  IOleObject              '00000112-0000-0000-C000-000000000046
  IOleInPlaceObject       '00000113-0000-0000-C000-000000000046
  IOleWindow              '00000114-0000-0000-C000-000000000046
  IOleInPlaceUIWindow     '00000115-0000-0000-C000-000000000046
  IOleInPlaceFrame        '00000116-0000-0000-C000-000000000046
  IOleInPlaceActiveObject '00000117-0000-0000-C000-000000000046
  IOleClientSite          '00000118-0000-0000-C000-000000000046
  IOleInPlaceSite         '00000119-0000-0000-C000-000000000046
  IParseDisplayName       '0000011A-0000-0000-C000-000000000046
  IOleContainer           '0000011B-0000-0000-C000-000000000046
  IOleItemContainer       '0000011C-0000-0000-C000-000000000046
  IOleLink                '0000011D-0000-0000-C000-000000000046
  IOleCache               '0000011E-0000-0000-C000-000000000046
  IDropSource             '00000121-0000-0000-C000-000000000046
  IDropTarget             '00000122-0000-0000-C000-000000000046
  IDebugStream            '00000124-0000-0000-C000-000000000046
  IAdviseSink2            '00000125-0000-0000-C000-000000000046
  IRunnableObject         '00000126-0000-0000-C000-000000000046
  IViewObject2            '00000127-0000-0000-C000-000000000046
  IOleCache2              '00000128-0000-0000-C000-000000000046
  IOleCacheControl        '00000129-0000-0000-C000-000000000046
  IInspectable            'af86e2e0-b12d-4c6a-9c5a-d7aa65101e90
End Enum

'Enumerator for InterfaceInfo parts, this can be useful while scraping / reflection
Public Enum EInterfaceInfoIndex
  sName
  iInvokeKind
  iOffset
  iDispID
End Enum

'[IUnknown](https://en.wikipedia.org/wiki/IUnknown)
'0      HRESULT  QueryInterface ([in] REFIID riid, [out] void **ppvObject)
'1      ULONG    AddRef ()
'2      ULONG    Release ()
Public Enum EIUnknown
  QueryInterface
  AddRef
  Release
End Enum

'[IDispatch](https://en.wikipedia.org/wiki/IDispatch)  extends IUnknown
'0      HRESULT  QueryInterface ([in] REFIID riid, [out] void **ppvObject)
'1      ULONG    AddRef ()
'2      ULONG    Release ()
'3      HRESULT  GetTypeInfoCount(unsigned int * pctinfo)
'4      HRESULT  GetTypeInfo(unsigned int iTInfo, LCID lcid, ITypeInfo ** ppTInfo)
'5      HRESULT  GetIDsOfNames(REFIID riid, OLECHAR ** rgszNames, unsigned int cNames, LCID lcid, DISPID * rgDispId)
'6      HRESULT  Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pDispParams, VARIANT * pVarResult, EXCEPINFO * pExcepInfo, unsigned int * puArgErr)
Public Enum EIDispatch
  QueryInterface
  AddRef
  Release
  GetTypeInfoCount
  GetTypeInfo
  GetIDsOfNames
  Invoke
End Enum

'[ITypeInfo](https://github.com/tpn/winsdk-10/blob/master/Include/10.0.16299.0/um/OAIdl.h#L2683) extends IUnknown
'0      HRESULT  QueryInterface ([in] REFIID riid, [out] void **ppvObject)
'1      ULONG    AddRef ()
'2      ULONG    Release ()
'3      HRESULT  GetTypeAttr([out] TYPEATTR **ppTypeAttr )
'4      HRESULT  GetTypeComp([out] ITypeComp **ppTComp )
'5      HRESULT  GetFuncDesc([in] UINT index, [out] FUNCDESC **ppFuncDesc)
'6      HRESULT  GetVarDesc([in] UINT index, [out] VARDESC **ppVarDesc)
'7      HRESULT  GetNames([in] MEMBERID memid, [out] BSTR *rgBstrNames, [in] UINT cMaxNames, [out] UINT *pcNames)
'8      HRESULT  GetRefTypeOfImplType( [in] UINT index, [out] HREFTYPE *pRefType)
'9      HRESULT  GetImplTypeFlags( [in] UINT index, [out] INT *pImplTypeFlags)
'10     HRESULT  GetIDsOfNames( [in] LPOLESTR *rgszNames, [in] UINT cNames, [out] MEMBERID *pMemId)
'11     HRESULT  Invoke( [in] PVOID pvInstance, [in] MEMBERID memid, [in] WORD wFlags, [out][in] DISPPARAMS *pDispParams, [out] VARIANT *pVarResult, [out] EXCEPINFO *pExcepInfo, [out] UINT *puArgErr)
'12     HRESULT  GetDocumentation( [in] MEMBERID memid, [out] BSTR *pBstrName, [out] BSTR *pBstrDocString, [out] DWORD *pdwHelpContext, [out] BSTR *pBstrHelpFile)
'13     HRESULT  GetDllEntry( [in] MEMBERID memid, [in] INVOKEKIND invKind, [out] BSTR *pBstrDllName, [out] BSTR *pBstrName, [out] WORD *pwOrdinal)
'14     HRESULT  GetRefTypeInfo( [in] HREFTYPE hRefType, [out] ITypeInfo **ppTInfo)
'15     HRESULT  AddressOfMember( [in] MEMBERID memid, [in] INVOKEKIND invKind, [out] PVOID *ppv)
'16     HRESULT  CreateInstance( [in] IUnknown *pUnkOuter, [in] REFIID riid, [out] PVOID *ppvObj)
'17     HRESULT  GetMops( [in] MEMBERID memid, [out] BSTR *pBstrMops)
'18     HRESULT  GetContainingTypeLib( [out] ITypeLib **ppTLib, [out] UINT *pIndex)
'19     void     ReleaseTypeAttr( [in] TYPEATTR *pTypeAttr)
'20     void     ReleaseFuncDesc( [in] FUNCDESC *pFuncDesc)
'21     void     ReleaseVarDesc( [in] VARDESC *pVarDesc)
Public Enum EITypeInfo
  QueryInterface
  AddRef
  Release
  GetTypeAttr
  GetTypeComp
  GetFuncDesc
  GetVarDesc
  GetNames
  GetRefTypeOfImplType
  GetImplTypeFlags
  GetIDsOfNames
  Invoke
  GetDocumentation
  GetDllEntry
  GetRefTypeInfo
  AddressOfMember
  CreateInstance
  GetMops
  GetContainingTypeLib
  ReleaseTypeAttr
  ReleaseFuncDesc
  ReleaseVarDesc
End Enum


'[IRunningObjectTable](https://github.com/tpn/winsdk-10/blob/9b69fd26ac0c7d0b83d378dba01080e93349c2ed/Include/10.0.14393.0/um/ObjIdl.Idl#L394-L440)
'@remark also see [IRunningObjectTable](https://github.com/khchen/winim/blob/master/winim/inc/objbase.nim#L598-L605) extends IUnknown
'0      HRESULT  QueryInterface      ([in]  REFIID riid, [out] void **ppvObject)
'1      HRESULT  AddRef              ()
'2      HRESULT  Release             ()
'3      HRESULT  Register            ([in]  DWORD grfFlags, [in] IUnknown *punkObject, [in] IMoniker *pmkObjectName, [out] DWORD *pdwRegister)
'4      HRESULT  Revoke              ([in]  DWORD dwRegister)
'5      HRESULT  IsRunning           ([in]  IMoniker *pmkObjectName)
'6      HRESULT  GetObject_           ([in]  IMoniker *pmkObjectName, [out] IUnknown **ppunkObject)
'7      HRESULT  NoteChangeTime      ([in]  DWORD dwRegister,[in] FILETIME *pfiletime)
'8      HRESULT  GetTimeOfLastChange ([in]  IMoniker *pmkObjectName, [out] FILETIME *pfiletime)
'9      HRESULT  EnumRunning         ([out] IEnumMoniker **ppenumMoniker)
Public Enum EIRunningObjectTable
  QueryInterface
  AddRef
  Release
  Register
  Revoke
  IsRunning
  GetObject_
  NoteChangeTime
  GetTimeOfLastChange
  EnumRunning
End Enum

'[IEnumVARIANT](https://github.com/tpn/winsdk-10/blob/master/Include/10.0.16299.0/um/OAIdl.h#L2398-L2432)
'0      HRESULT  QueryInterface      ([in]  REFIID riid, [out] void **ppvObject)
'1      HRESULT  AddRef              ()
'2      HRESULT  Release             ()
'3      HRESULT  Next                ([in]  ULONG   countToFetch, [out] VARIANT *varArray ,[out] ULONG *pCountFetched)
'4      HRESULT  Skip                ([in]  ULONG   countToSkip)
'5      HRESULT  Reset               ()
'6      HRESULT  Clone               ([out] IEnumVARIANT **ppEnum)
Public Enum EIEnumVARIANT
  QueryInterface
  AddRef
  Release
  Nextt
  Skip
  Reset
  Clone
End Enum

'[IEnumMoniker](https://github.com/tpn/winsdk-10/blob/9b69fd26ac0c7d0b83d378dba01080e93349c2ed/Include/10.0.14393.0/um/ObjIdl.Idl#L325-L352)
'@remark Also see https://fossies.org/dox/wine-6.0.2/interfaceIEnumMoniker.html; RemoteNext is not documented on docs.microsoft.com
'0      HRESULT  QueryInterface      ([in]  REFIID riid, [out] void **ppvObject)
'1      HRESULT  AddRef              ()
'2      HRESULT  Release             ()
'3      HRESULT  Next                ([in]  ULONG   countToFetch, [out] IMoniker *varArray ,[out] ULONG *pCountFetched)
'4      HRESULT  RemoteNext          ([in]  ULONG   countToFetch, [out] IMoniker *varArray ,[out] ULONG *pCountFetched)
'5      HRESULT  Skip                ([in]  ULONG   countToSkip)
'6      HRESULT  Reset               ()
'7      HRESULT  Clone               ([out] IEnumMoniker **ppenum)
Public Enum EIEnumMoniker
  QueryInterface
  AddRef
  Release
  Nextt    'or RemoteNext
  Skip
  Reset
  Clone
End Enum

'[IMoniker](https://github.com/tpn/winsdk-10/blob/9b69fd26ac0c7d0b83d378dba01080e93349c2ed/Include/10.0.14393.0/um/ObjIdl.Idl#L504-L621)
'@devNote includes [IUnknown](https://en.wikipedia.org/wiki/IUnknown)
'@devNote includes [IPersist](https://github.com/tpn/winsdk-10/blob/9b69fd26ac0c7d0b83d378dba01080e93349c2ed/Include/10.0.14393.0/um/ObjIdl.Idl#L453-L462)
'@devNote includes [IPersistStream](https://github.com/tpn/winsdk-10/blob/9b69fd26ac0c7d0b83d378dba01080e93349c2ed/Include/10.0.14393.0/um/ObjIdl.Idl#L470-L496)
'0      HRESULT QueryInterface      ([in]  REFIID riid, [out] void **ppvObject)
'1      HRESULT AddRef              ()
'2      HRESULT Release             ()
'3      HRESULT GetClassID          ([out] CLSID *pClassID)
'4      HRESULT IsDirty             ()
'5      HRESULT Load                ([in] IStream *pStm)
'6      HRESULT Save                ([in] IStream *pStm, [in] BOOL fClearDirty)
'7      HRESULT GetSizeMax          ([out] ULARGE_INTEGER *pcbSize)
'8      HRESULT BindToObject        ([in] IBindCtx *pbc, [in] IMoniker *pmkToLeft, [in] REFIID riidResult, [out] void **ppvResult)       'or RemoteBindToObject
'9      HRESULT BindToStorage       ([in] IBindCtx *pbc, [in] IMoniker *pmkToLeft, [in] REFIID riidResult, [out] void **ppvResult)       'or RemoteBindToStorage
'10     HRESULT Reduce              ([in] IBindCtx *pbc, [in] DWORD dwReduceHowFar,[in, out] IMoniker **ppmkToLeft, [out] IMoniker **ppmkReduced)
'11     HRESULT ComposeWith         ([in] IMoniker *pmkRight, [in] BOOL fOnlyIfNotGeneric, [out] IMoniker **ppmkComposite)
'12     HRESULT Enum                ([in] BOOL fForward, [out] IEnumMoniker **ppenumMoniker)
'13     HRESULT IsEqual             ([in] IMoniker *pmkOtherMoniker)
'14     HRESULT Hash                ([out] DWORD *pdwHash)
'15     HRESULT IsRunning           ([in] IBindCtx *pbc, [in] IMoniker *pmkToLeft, [in] IMoniker *pmkNewlyRunning)
'16     HRESULT GetTimeOfLastChange ([in] IBindCtx *pbc, [in] IMoniker *pmkToLeft, [out] FILETIME *pFileTime)
'17     HRESULT Inverse             ([out] IMoniker **ppmk)
'18     HRESULT CommonPrefixWith    ([in] IMoniker *pmkOther, [out] IMoniker **ppmkPrefix)
'19     HRESULT RelativePathTo      ([in] IMoniker *pmkOther, [out] IMoniker **ppmkRelPath)
'20     HRESULT GetDisplayName      ([in] IBindCtx *pbc, [in] IMoniker *pmkToLeft, [out] LPOLESTR *ppszDisplayName)
'21     HRESULT ParseDisplayName    ([in] IBindCtx *pbc, [in] IMoniker *pmkToLeft, [in] LPOLESTR pszDisplayName, [out] ULONG *pchEaten, [out] IMoniker **ppmkOut)
'22     HRESULT IsSystemMoniker     ([out] DWORD *pdwMksys)
Public Enum EIMoniker
  QueryInterface
  AddRef
  Release
  GetClassID
  IsDirty
  Load
  Save
  GetSizeMax
  BindToObject
  BindToStorage
  reduce
  ComposeWith
  Enumm
  IsEqual
  Hash
  IsRunning
  GetTimeOfLastChange
  Inverse
  CommonPrefixWith
  RelativePathTo
  GetDisplayName
  ParseDisplayName
  IsSystemMoniker
End Enum

'[IPropertyStore](https://github.com/maul-esel/COM-Classes/blob/master/PropertyStore/PropertyStore.ahk)
'@devNote includes [IUnknown](https://en.wikipedia.org/wiki/IUnknown)
Private Enum EIPropertyStore
  QueryInterface
  AddRef
  Release
  GetCount   'DllCall(NumGet(this.vt+03*A_PtrSize), "ptr", this.ptr, "uint*", count)
  GetAt      'DllCall(NumGet(this.vt+04*A_PtrSize), "ptr", this.ptr, "uint", index, "ptr*", out)
  GetValue   'DllCall(NumGet(this.vt+05*A_PtrSize), "ptr", this.ptr, "ptr", formatStruct, "ptr*", out)
  SetValue   'DllCall(NumGet(this.vt+06*A_PtrSize), "ptr", this.ptr, "ptr", formatStruct, "ptr", value)
  Commit     'DllCall(NumGet(this.vt+07*A_PtrSize), "ptr", this.ptr)
End Enum

Public Enum EPropertyStoreFlags
  GPS_DEFAULT = 0
  GPS_HANDLERPROPERTIESONLY = &H1
  GPS_READWRITE = &H2
  GPS_TEMPORARY = &H4
  GPS_FASTPROPERTIESONLY = &H8
  GPS_OPENSLOWITEM = &H10
  GPS_DELAYCREATION = &H20
  GPS_BESTEFFORT = &H40
  GPS_NO_OPLOCK = &H80
  GPS_PREFERQUERYPROPERTIES = &H100
  GPS_EXTRINSICPROPERTIES = &H200
  GPS_EXTRINSICPROPERTIESONLY = &H400
  GPS_VOLATILEPROPERTIES = &H800
  GPS_VOLATILEPROPERTIESONLY = &H1000
  GPS_MASK_VALID = &H1fff
End Enum

Private Const S_OK          As Long = 0
Private Const E_NOINTERFACE As Long = &H80004002
Private Const E_POINTER     As Long = &H80004003
Private Const CC_STDCALL    As Long = 4

#If Win64 Then
  Private Const PTRSIZE = 8
  Private Const vbLongPtr = VbVarType.vbLongLong
#Else
  Private Const PTRSIZE = 4
  Private Const vbLongPtr = VbVarType.vbLong
#End If


'*******************
'* STATE VARIABLES *
'*******************
Private Type TThis
  Meta As IUnknown
  RegisteredOLEInstance As Long
  RegisteredTimerOLEInstance As Long
  #If VBA7 Then
    ObjPtr As LongPtr
  #Else
    ObjPtr as Long
  #End If
End Type
Private This As TThis

'**********
'* EVENTS *
'**********

'****************
'* CONSTRUCTORS *
'****************

'Create from an object
'@constructor
'@param obj - Object to create raw COM object from
'@returns - A wrapper around a raw COM object
Public Function Create(ByRef obj As IUnknown) As stdCOM
  With stdError.getSentry("stdCOM#Create", "obj", obj)
    On Error GoTo stdErrorWrapper_ErrorOccurred
    
      Set Create = New stdCOM
      Call Create.protInitFromObject(obj)
    
    Exit Function
    stdErrorWrapper_ErrorOccurred:
      Call Err_Raise(Err.Number, Err.Source, Err.Description)
  End With
End Function

'Create from a pointer
'@constructor
'@param ptr - Object pointer to wrap in a raw COM object
'@param bAddRef - Whether to call `AddRef` on the object
'@returns - A wrapper around a raw COM object
'@remark Specifically this function reuires a `*Interface` pointer. E.G. `*IUnknown`/`*IDispatch`/`*ITypeInfo`. If your DLL function provides a `[out] **Interface` object the
'typical method is to pass in a varptr to the dll function as follows `Call SomeDLLCall(VarPtr(myPointer)): ... later ...: stdCOM.CreateFromPtr(myPointer)`
#If VBA7 Then
Public Function CreateFromPtr(ByVal ptr As LongPtr, Optional ByVal bAddRef As Boolean = True) As stdCOM
#Else
  Public Function CreateFromPtr(ByVal ptr As Long, Optional ByVal bAddRef As Boolean = True) As stdCOM
#End If
  With stdError.getSentry("stdCOM#CreateFromPtr", "ptr", ptr, "bAddRef", bAddRef)
    On Error GoTo stdErrorWrapper_ErrorOccurred
    
      Set CreateFromPtr = New stdCOM
      Call CreateFromPtr.protInitFromPtr(ptr, bAddRef)
    
    Exit Function
    stdErrorWrapper_ErrorOccurred:
      Call Err_Raise(Err.Number, Err.Source, Err.Description)
  End With
End Function

'Create `stdCOM` objects from existing objects in the RunningObjectTable (ROT)
'@constructor
'@returns - A collection of `stdCOM` objects
'@remark This function is heavily inspired off code provided by `Jaafar Tribak`
'@devNote stdCOM objects will auto-release when not needed
Public Function CreateFromActiveObjects() As Collection
  With stdError.getSentry("stdCOM#CreateFromActiveObjects")
    On Error GoTo stdErrorWrapper_ErrorOccurred
    
      #If VBA7 Then
        Dim pROT As LongPtr, pBindCtx As LongPtr, pEnumMoniker As LongPtr, pMoniker As LongPtr, pStr As LongPtr, pMonikerObject As LongPtr
      #Else
        Dim pROT As Long, pBindCtx As Long, pEnumMoniker As Long, pMoniker As Long, pStr As Long, pMonikerObject As Long
      #End If
      
      Dim ret As Collection: Set ret = New Collection 'Collection to return
      If CLng(GetRunningObjectTable(0, pROT)) <> S_OK Then Exit Function                               '*IRunningObjectTable
      If CLng(CreateBindCtx(0, pBindCtx)) <> S_OK Then Exit Function                                   '*IBindCtx
      Dim CTX As stdCOM: Set CTX = stdCOM.CreateFromPtr(pBindCtx)                                      'stdCOM<IBindCtx>
      Dim ROT As stdCOM: Set ROT = stdCOM.CreateFromPtr(pROT).QueryKnownInterface(IRunningObjectTable) 'stdCOM<IRunningObjectTable>
      Call ROT.CallVT(EIRunningObjectTable.EnumRunning, vbLong, VarPtr(pEnumMoniker))                  '*IEnumMoniker
      Dim e As stdCOM: Set e = stdCOM.CreateFromPtr(pEnumMoniker)                                      'stdCOM<IEnumMoniker>
      'Dim e As stdCOM: Set e = ROT.CallVTW(EIRunningObjectTable.EnumRunning, vbLong, Null)            'stdCOM<IEnumMoniker>
      
      'Enumerate ROT
      Dim nCount As Long: nCount = 1&
      Dim nCountFetched As Long: nCountFetched = 1& 'Note: This has to be set else a crash occurs
      Do While e.CallVT(EIEnumMoniker.Nextt, vbLong, nCount, VarPtr(pMoniker), VarPtr(nCountFetched)) = S_OK     '*IMoniker
        'Note: This check is required, in some instances (still not certain when specifically) S_OK is returned, despite `nCountFetched` holding `0` and `nCount` holding `1`
        If nCountFetched = 0 Then Exit Do
    
        Dim moniker As stdCOM: Set moniker = stdCOM.CreateFromPtr(pMoniker)                                   'stdCOM<IMoniker>
    
        'Get DisplayName and Object
        Dim sName As String: If moniker.CallVT(EIMoniker.GetDisplayName, vbLong, VarPtr(pBindCtx), VarPtr(pMoniker), VarPtr(pStr)) = S_OK Then _
            sName = GetStrFromPtrW(pStr)
        Call ROT.CallVT(EIRunningObjectTable.GetObject_, vbLong, pMoniker, VarPtr(pMonikerObject))                          '*Interface
        Dim obj As stdCOM: Set obj = stdCOM.CreateFromPtr(pMonikerObject)                                                  'stdCOM<Interface>
        
        'Get ProgID from PathName
        Dim CLSID As GUID: CLSID.Data1 = 0: CLSID.Data2 = 0: CLSID.Data3 = 0: Erase CLSID.Data4
        Dim ProgID As String: ProgID = ""
        If sName Like "!{*}" Then
          Dim tCLSID As String: tCLSID = Mid(sName, 2)
          Call IIDFromString(StrPtr(tCLSID), CLSID)
          If ProgIDFromCLSID(CLSID, VarPtr(pStr)) = S_OK Then
            ProgID = GetStrFromPtrW(pStr)
          End If
        End If
        
        'Wrap return value in dictionary for easy enumeration with stdLambda
        Dim oDict As Object: Set oDict = CreateObject("Scripting.Dictionary")
        oDict("Name") = sName
        oDict("Type") = TypeName(obj.Object)
        oDict("ProgID") = ProgID
        Set oDict("COM") = obj
        ret.Add oDict
      Loop
      
      Set CreateFromActiveObjects = ret
    
    Exit Function
    stdErrorWrapper_ErrorOccurred:
      Call Err_Raise(Err.Number, Err.Source, Err.Description)
  End With
End Function

'Create `stdCOM` object from WinRT Activatable ClassID.
'@constructor
'@param sActivatableClassId - An activatable WinRT class ID.
'@returns - A COM wrapper for the object.
'@example ```vb
'stdCOM.CreateFromWinRTClassID("Windows.Storage.Pickers.FolderPicker")
'```
Public Function CreateFromWinRTClassID(ByVal sActivatableClassId As String) As stdCOM
  With stdError.getSentry("stdCOM#CreateFromWinRTClassID", "sActivatableClassId", sActivatableClassId)
    On Error GoTo stdErrorWrapper_ErrorOccurred
    
      Dim hString As LongPtr
      If WindowsCreateString(StrPtr(sActivatableClassId), Len(sActivatableClassId), hString) <> S_OK Then Err_Raise 1, "stdCOM::CreateFromWinRTClassID", "Cannot create HSTRING"
      If hString = NULL_PTR Then Err_Raise 1, "stdCOM::CreateFromWinRTClassID", "Cannot create HSTRING"
    
      'Obtain stdCOM object
      Dim pIInspectable As LongPtr
      If RoActivateInstance(hString, pIInspectable) <> S_OK Then Err_Raise 1, "stdCOM::CreateFromWinRTClassID", "Cannot activate class ID"
      If pIInspectable = 0 Then Err_Raise 1, "stdCOM::CreateFromWinRTClassID", "Cannot activate class ID"
      Set CreateFromWinRTClassID = CreateFromPtr(pIInspectable)
    
      'Delete string
      Call WindowsDeleteString(hString)
    
    Exit Function
    stdErrorWrapper_ErrorOccurred:
      Call Err_Raise(Err.Number, Err.Source, Err.Description)
  End With
End Function


'Create `stdCOM` object from a CLSID and IID.
'@constructor
'@param sClassID - A CLSID as a string.
'@param sIID - An IID as a string. Default is `IDispatch`.
'@returns - A COM wrapper for the object.
'@example ```vb
'  stdCOM.CreateFromClassAndIID("{FF48DBA4-60EF-4201-AA87-54103EEF594E}","{30CBE57D-D9D0-452A-AB13-7AC5AC4825EE}") 'IUIAutomation
'```
Public Function CreateFromClassAndIID(ByVal sClassID As String, Optional ByVal sIID As String = "{00020400-0000-0000-C000-000000000046}") As stdCOM
  With stdError.getSentry("stdCOM#CreateFromClassAndIID", "sClassID", sClassID, "sIID", sIID)
    On Error GoTo stdErrorWrapper_ErrorOccurred
    
      Dim clsid As GUID: If IIDFromString(StrPtr(sClassID), clsid) <> S_OK Then Err_Raise 1, "stdCOM::CreateFromClassAndIID", "Cannot retrieve CLSID from String."
      Dim iid As GUID: If IIDFromString(StrPtr(sIID), iid) <> S_OK Then Err_Raise 1, "stdCOM::CreateFromClassAndIID", "Cannot retrieve IID from String."
      Const CLSCTX_INPROC_SERVER = &H1
    
      Dim pIUnknown As LongPtr
      If CoCreateInstance(clsid, NULL_PTR, CLSCTX_INPROC_SERVER, iid, pIUnknown) <> S_OK Then Err_Raise 1, "stdCOM::CreateFromClassAndIID", "Cannot create object from CLSID and IID."
      
      Set CreateFromClassAndIID = CreateFromPtr(pIUnknown)
    
    Exit Function
    stdErrorWrapper_ErrorOccurred:
      Call Err_Raise(Err.Number, Err.Source, Err.Description)
  End With
End Function

'Create a `stdCOM` object from a property store path
'@constructor
'@TODO: Figure out why this function doesn't work... See: https://www.mrexcel.com/board/threads/editing-mp3-tags.1104401/page-2#post-6157709
'@param sPath - Path to property store
'@param flags - Flags to use when opening the property store
'@returns - `stdCOM` object representing the property store
'@example ```vb
'Dim p as stdCOM: set p = stdCOM.CreatePropertyStoreFromFile("C:\my\files\song.mp3", EPropertyStoreFlags.GPS_READWRITE Or EPropertyStoreFlags.GPS_OPENSLOWITEM)
'```
Public Function CreatePropertyStoreFromFile(ByVal sPath As String, Optional flags As EPropertyStoreFlags = GPS_READWRITE Or GPS_OPENSLOWITEM) As stdCOM
  With stdError.getSentry("stdCOM#CreatePropertyStoreFromFile", "sPath", sPath, "flags", flags)
    On Error GoTo stdErrorWrapper_ErrorOccurred
    
      Const IID_PropertyStore = "{886D8EEB-8CF2-4446-8D02-CDBA1DBDCF99}"
      Dim clsid As GUID: If IIDFromString(StrPtr(IID_PropertyStore), clsid) <> S_OK Then Err_Raise 1, "stdCOM::CreateFromPropertyStore", "Cannot retrieve IID from String."
      Dim pIUnknown As LongPtr
      If SHGetPropertyStoreFromParsingName(StrPtr(sPath), ByVal NULL_PTR, flags, clsid, pIUnknown) = S_OK Then
        Set CreatePropertyStoreFromFile = CreateFromPtr(pIUnknown, false)
      Else
        Err_Raise 1, "stdCOM::CreatePropertyStoreFromFile", "Cannot create object from path."
      End If
    
    Exit Function
    stdErrorWrapper_ErrorOccurred:
      Call Err_Raise(Err.Number, Err.Source, Err.Description)
  End With
End Function

'#################################
'# INSTANCE METHODS / PROPERTIES #
'#################################

'Obtain raw object from stdCOM wrapper
'@returns - Raw object
'@example ```vb
'stdCOM.Create(Application).Object.Name
'```
'@example ```vb
'stdCOM.CreateFromPtr(ObjPtr(Application)).Object.Name
'```
Public Property Get Object() As IUnknown
  With stdError.getSentry("stdCOM#Object[Get]")
    On Error GoTo stdErrorWrapper_ErrorOccurred
    
      If This.Meta Is Nothing Then
        Set Object = Deref(This.ObjPtr)
      Else
        Set Object = This.Meta
      End If
    
    Exit Property
    stdErrorWrapper_ErrorOccurred:
      Call Err_Raise(Err.Number, Err.Source, Err.Description)
  End With
End Property

'Obtain raw object from stdCOM wrapper
'@returns - `IDispatch` for object
'@example ```vb
'stdCOM.Create(Application).Object.Name
'```
'@example ```vb
'stdCOM.CreateFromPtr(ObjPtr(Application)).Object.Name
'```
'@throws {...} Unsupported interface IDispatch
Public Property Get AsObject() As Object
  With stdError.getSentry("stdCOM#AsObject[Get]")
    On Error GoTo stdErrorWrapper_ErrorOccurred
    
      If This.Meta Is Nothing Then
        Set AsObject = Deref(This.ObjPtr)
      Else
        Set AsObject = This.Meta
      End If
    
    Exit Property
    stdErrorWrapper_ErrorOccurred:
      Call Err_Raise(Err.Number, Err.Source, Err.Description)
  End With
End Property

'Obtain pointer as LongPtr (VBA)/Long (VB6)
'@returns - Pointer to object
#If VBA7 Then
Public Property Get Pointer() As LongPtr
#Else
  Public Property Get Pointer() As Long
#End If
  With stdError.getSentry("stdCOM#Pointer[Get]")
    On Error GoTo stdErrorWrapper_ErrorOccurred
    
      If This.Meta Is Nothing Then
        Pointer = This.ObjPtr
      Else
        Pointer = ObjPtr(This.Meta)
      End If
    
    Exit Property
    stdErrorWrapper_ErrorOccurred:
      Call Err_Raise(Err.Number, Err.Source, Err.Description)
  End With
End Property

'Call `IUnknown::QueryInterface` on the object
'@param sIID - Interface Identifier as string
'@returns - `stdCOM` object for interface
'@throws stdCOM<IUnknown>#unkQueryInterface - Cannot retrieve IID from String.
'@throws stdCOM<IUnknown>#unkQueryInterface - Interface not implemented.
'@throws stdCOM<IUnknown>#unkQueryInterface - Unknown error occurred.
'@example ```vb
'  'Get ITypeInfo
'  set typeInfo = com.unkQueryInterface("00020401-0000-0000-C000-000000000046")
'```
Public Function unkQueryInterface(ByVal sIID As String) As stdCOM
  With stdError.getSentry("stdCOM#unkQueryInterface", "sIID", sIID)
    On Error GoTo stdErrorWrapper_ErrorOccurred
    
      Dim IInterface As IUnknown
      Dim tGUID As GUID
      If IIDFromString(StrPtr(sIID), tGUID) = S_OK Then
        Dim hResult As Long: hResult = CallVT(EIUnknown.QueryInterface, vbLong, VarPtr(tGUID.Data1), VarPtr(IInterface))
        If hResult = S_OK Then
          If IInterface Is Nothing Then
            Set unkQueryInterface = Nothing
          Else
            Set unkQueryInterface = stdCOM.Create(IInterface)
          End If
        ElseIf hResult = E_POINTER Then
          Set unkQueryInterface = Nothing
        ElseIf hResult = E_NOINTERFACE Then
          Err_Raise E_NOINTERFACE, "stdCOM<IUnknown>#unkQueryInterface", "Interface not implemented."
        Else
          Err_Raise hResult, "stdCOM<IUnknown>#unkQueryInterface", "Unknown error occurred."
        End If
      Else
        Err_Raise Err.LastDllError, "stdCOM<IUnknown>#unkQueryInterface", "Cannot retrieve IID from String."
      End If
    
    Exit Function
    stdErrorWrapper_ErrorOccurred:
      Call Err_Raise(Err.Number, Err.Source, Err.Description)
  End With
End Function

'Call `IUnknown::AddRef()`
Public Sub unkAddRef()
  With stdError.getSentry("stdCOM#unkAddRef")
    On Error GoTo stdErrorWrapper_ErrorOccurred
    
      CallVT EIUnknown.AddRef, vbLong
    
    Exit Sub
    stdErrorWrapper_ErrorOccurred:
      Call Err_Raise(Err.Number, Err.Source, Err.Description)
  End With
End Sub

'Call IUnknown::Release()
Public Sub unkRelease()
  With stdError.getSentry("stdCOM#unkRelease")
    On Error GoTo stdErrorWrapper_ErrorOccurred
    
      CallVT EIUnknown.Release, vbLong
    
    Exit Sub
    stdErrorWrapper_ErrorOccurred:
      Call Err_Raise(Err.Number, Err.Source, Err.Description)
  End With
End Sub

'Query the object for a known interface.
'@param interface - Known interface to query for
'@returns - interface queried.
'@throws "Interface IID not known."
Public Function QueryKnownInterface(ByVal interface As EKnownInterfaces) As stdCOM
  With stdError.getSentry("stdCOM#QueryKnownInterface", "interface", interface)
    On Error GoTo stdErrorWrapper_ErrorOccurred
    
      Dim sIID As String: sIID = KnownIID(interface)
      If sIID <> "" Then
        Dim oRet As stdCOM: Set oRet = unkQueryInterface(sIID)
        If Not oRet Is Nothing Then Call oRet.unkAddRef
        Set QueryKnownInterface = oRet
      Else
        Err_Raise 1, "stdCOM::QueryKnownInterface", "Interface IID not known."
      End If
    
    Exit Function
    stdErrorWrapper_ErrorOccurred:
      Call Err_Raise(Err.Number, Err.Source, Err.Description)
  End With
End Function


'Obtain Type Information from object
'@returns stdCOM<ITypeInfo> - TypeInfo structure for this object
'@example ```vb
'myCom.TypeInfo.CallVT(EITypeInfo.GetTypeAttr, vbLong, VarPtr(lPtr))
'```
Public Property Get TypeInfo() As stdCOM
  With stdError.getSentry("stdCOM#TypeInfo[Get]")
    On Error GoTo stdErrorWrapper_ErrorOccurred
    
      On Error GoTo CannotQuery
        Set TypeInfo = QueryKnownInterface(ITypeInfo)
        If TypeInfo Is Nothing Then GoTo CannotQuery
        Exit Property
    CannotQuery:
      On Error GoTo UnknownError
      'Attempt to query from IDispatch
      With QueryKnownInterface(IDispatch)
        Dim pTypeInfo As IUnknown
        Dim hResult As Long: hResult = .CallVT(EIDispatch.GetTypeInfo, vbLongPtr, NULL_PTR, NULL_PTR, VarPtr(pTypeInfo))
        If hResult <> S_OK Then Err_Raise hResult, "InterfaceInfo", "stdCOM::InterfaceInfo"
        If Not pTypeInfo Is Nothing Then Set TypeInfo = stdCOM.Create(pTypeInfo)
      End With
      Exit Property
    UnknownError:
      Set TypeInfo = Nothing
    
    Exit Property
    stdErrorWrapper_ErrorOccurred:
      Call Err_Raise(Err.Number, Err.Source, Err.Description)
  End With
End Property

'Obtain all properties and methods of an object via it's TypeInfo
'@returns Collection<Array<string, vbCallType, long, long>> - Collection of arrays containing Method/Property name, CallType, Index in type info and DispID
Public Property Get InterfaceInfo() As Collection
  With stdError.getSentry("stdCOM#InterfaceInfo[Get]")
    On Error GoTo stdErrorWrapper_ErrorOccurred
    
      Static pInterfaceInfo As Collection
      If pInterfaceInfo Is Nothing Then
        'Wrap pTypeInfo in stdCOM
        Dim oTypeInfo As stdCOM: Set oTypeInfo = TypeInfo()
        If oTypeInfo Is Nothing Then
            Set InterfaceInfo = New Collection
            Exit Property
        End If
        
        #If Win64 Then
          Dim lPtr As LongLong
          Const CountPos As Long = 12
        #Else
          Dim lPtr As Long
          Const CountPos As Long = 11
        #End If
        'Get TypeAttribute
        Call oTypeInfo.CallVT(EITypeInfo.GetTypeAttr, vbLong, VarPtr(lPtr))
        
        'Fix bug in VBA/VB6 engine - for some reason the next CopyMemory statement will set the following
        'value to nothing
        Dim vTmp: Set vTmp = oTypeInfo
        
        'Only fill the type size which is required, otherwise we'd use LENB(tTypeAttr)
        Dim tTypeAttr As TYPEATTR
        CopyMemory tTypeAttr, ByVal lPtr, LenB(tTypeAttr)
        
        'Release TypeAttribute
        Call oTypeInfo.CallVT(EITypeInfo.ReleaseTypeAttr, vbLong, lPtr)
        
        Dim oRet As Collection
        Set oRet = New Collection
        
        Dim tFuncDesc As FUNCDESC
        Dim iFuncMemSize As Long: iFuncMemSize = 2 * PTRSIZE + 12: iFuncMemSize = LenB(tFuncDesc)
        
        'Enumerate over all members of typeinfo
        Dim i As Long
        For i = 0 To tTypeAttr.cFuncs - 1
          lPtr = 0
          Call oTypeInfo.CallVT(EITypeInfo.GetFuncDesc, vbLong, i, VarPtr(lPtr))
          If lPtr <> 0 Then
            CopyMemory tFuncDesc, ByVal lPtr, iFuncMemSize
            Call oTypeInfo.CallVT(EITypeInfo.ReleaseFuncDesc, vbLong, lPtr)
            
            Dim sName As String: sName = vbNullString
            Call oTypeInfo.CallVT(EITypeInfo.GetDocumentation, vbLong, tFuncDesc.memid, VarPtr(sName), NULL_PTR, NULL_PTR, NULL_PTR)
            oRet.Add Array(sName, tFuncDesc.INVOKEKIND, i, tFuncDesc.memid)
          End If
          If (i Mod 50) = 0 Then DoEvents
        Next
        Set pInterfaceInfo = oRet
      End If
      
      Set InterfaceInfo = pInterfaceInfo
      Exit Property
    UnknownError:
      Set InterfaceInfo = Nothing
    
    Exit Property
    stdErrorWrapper_ErrorOccurred:
      Call Err_Raise(Err.Number, Err.Source, Err.Description)
  End With
End Property

'Obtain a collection of all method names on an object
'@returns Collection<string> - Collection of method names
Public Property Get Methods() As Collection
  With stdError.getSentry("stdCOM#Methods[Get]")
    On Error GoTo stdErrorWrapper_ErrorOccurred
    
      Static oMethods As Collection
      If oMethods Is Nothing Then
        Set oMethods = New Collection
        Dim info As Variant
        For Each info In InterfaceInfo
          If info(1) = vbMethod Then
            oMethods.Add info(0)
          End If
        Next
      End If
      Set Methods = oMethods
    
    Exit Property
    stdErrorWrapper_ErrorOccurred:
      Call Err_Raise(Err.Number, Err.Source, Err.Description)
  End With
End Property

'Obtain a collection of all property names on an object
'@param bIncludeReadWriteType - Include GET/LET/SET/UNK prefixes representing call conv
'@returns Collection<string> - Collection of property names
'@example ```vb
'  for each vProp in stdCOM.Create(Application).Properties
'    Debug.Print vProp
'  next
'```
Public Property Get Properties(Optional bIncludeReadWriteType As Boolean = False) As Collection
  With stdError.getSentry("stdCOM#Properties[Get]", "bIncludeReadWriteType", bIncludeReadWriteType)
    On Error GoTo stdErrorWrapper_ErrorOccurred
    
      Static oProperties As Collection
      If oProperties Is Nothing Then
        Set oProperties = New Collection
        Dim info As Variant
        For Each info In InterfaceInfo
          If info(1) <> vbMethod Then
              Dim sReadWritePrefix As String
              If bIncludeReadWriteType Then
                Select Case info(1)
                  Case vbGet: sReadWritePrefix = "GET"
                  Case vbLet: sReadWritePrefix = "LET"
                  Case vbSet: sReadWritePrefix = "SET"
                  Case Else: sReadWritePrefix = "UNK"
                End Select
                oProperties.Add sReadWritePrefix & " " & info(0)
              Else
                On Error Resume Next
                  oProperties.Add info(0), info(0)
                On Error GoTo stdErrorWrapper_ErrorOccurred
              End If
          End If
        Next
      End If
    
      Set Properties = oProperties
    
    Exit Property
    stdErrorWrapper_ErrorOccurred:
      Call Err_Raise(Err.Number, Err.Source, Err.Description)
  End With
End Property

'Register the object held in stdCOM to the ROT as a CLSID or ProgID
'@param sCLSID - CLSID if required. If this arg isn't provided, a ProgID must be provided.
'@param ProgID - ProgID if required. If this arg isn't provided, a CLSID must be provided.
Public Sub RegisterActiveObject(Optional ByVal sCLSID As String = "", Optional ByVal ProgID As String = "")
  With stdError.getSentry("stdCOM#RegisterActiveObject", "sCLSID", sCLSID, "ProgID", ProgID)
    On Error GoTo stdErrorWrapper_ErrorOccurred
    
        Call RegisterActiveObjectEx(Object, This.RegisteredOLEInstance, sCLSID, ProgID)
    
    Exit Sub
    stdErrorWrapper_ErrorOccurred:
      Call Err_Raise(Err.Number, Err.Source, Err.Description)
  End With
End Sub

'Revoke the previously registered object
Public Sub RevokeActiveObject()
  With stdError.getSentry("stdCOM#RevokeActiveObject")
    On Error GoTo stdErrorWrapper_ErrorOccurred
    
        Call RevokeActiveObjectEx(Object, This.RegisteredOLEInstance)
    
    Exit Sub
    stdErrorWrapper_ErrorOccurred:
      Call Err_Raise(Err.Number, Err.Source, Err.Description)
  End With
End Sub

'Get the number of properties in the property store
'@returns - The number of properties
'@remark - `IPropertyStore` helper method.
Public Function PropertyStore_GetCount() As Long
  With stdError.getSentry("stdCOM#PropertyStore_GetCount")
    On Error GoTo stdErrorWrapper_ErrorOccurred
    
      Call CallVt(EIPropertyStore.GetCount, vbLong, VarPtr(PropertyStore_GetCount))
    
    Exit Function
    stdErrorWrapper_ErrorOccurred:
      Call Err_Raise(Err.Number, Err.Source, Err.Description)
  End With
End Function

'Get a property at a given index
'@param index - The index of the property to get
'@returns - The property at the given index. Use `CopyMemory` to copy the data.
'@remark - `IPropertyStore` helper method.
Public Function PropertyStore_GetAt(ByVal index As Long) As LongPtr
  With stdError.getSentry("stdCOM#PropertyStore_GetAt", "index", index)
    On Error GoTo stdErrorWrapper_ErrorOccurred
    
      Call CallVt(EIPropertyStore.GetAt, vbLong, VarPtr(index), VarPtr(PropertyStore_GetAt))
    
    Exit Function
    stdErrorWrapper_ErrorOccurred:
      Call Err_Raise(Err.Number, Err.Source, Err.Description)
  End With
End Function

'Get a property value
'@param formatID - The format ID of the property to get
'@param propID - The property ID of the property to get
'@returns - The property value.
'@remark - `IPropertyStore` helper method.
Public Function PropertyStore_GetValue(ByVal formatID as string, ByVal propID as long) As Variant
  With stdError.getSentry("stdCOM#PropertyStore_GetValue", "formatID", formatID, "propID", propID)
    On Error GoTo stdErrorWrapper_ErrorOccurred
    
      Dim format as PropertyKey
      Call IIDFromString(StrPtr(formatID), format.formatID)
      format.propID = propID
      Call CallVt(EIPropertyStore.GetValue, vbLong, VarPtr(format), VarPtr(PropertyStore_GetValue))
    
    Exit Function
    stdErrorWrapper_ErrorOccurred:
      Call Err_Raise(Err.Number, Err.Source, Err.Description)
  End With
End Function

'Set a property value
'@param formatID - The format ID of the property to get
'@param propID - The property ID of the property to get
'@param value - The value to set the property to
'@remark - `IPropertyStore` helper method.
Public Sub PropertyStore_SetValue(ByVal formatID as string, ByVal propID as long, ByVal value as variant)
  With stdError.getSentry("stdCOM#PropertyStore_SetValue", "formatID", formatID, "propID", propID, "value", value)
    On Error GoTo stdErrorWrapper_ErrorOccurred
    
      Dim format as PropertyKey
      Call IIDFromString(StrPtr(formatID), format.formatID)
      format.propID = propID
      Call CallVt(EIPropertyStore.SetValue, vbLong, VarPtr(format), VarPtr(value))
    
    Exit Sub
    stdErrorWrapper_ErrorOccurred:
      Call Err_Raise(Err.Number, Err.Source, Err.Description)
  End With
End Sub

'Commit the changes to the property store
'@remark - `IPropertyStore` helper method.
Public Sub PropertyStore_Commit()
  With stdError.getSentry("stdCOM#PropertyStore_Commit")
    On Error GoTo stdErrorWrapper_ErrorOccurred
    
      Call CallVt(EIPropertyStore.Commit, vbLong)
    
    Exit Sub
    stdErrorWrapper_ErrorOccurred:
      Call Err_Raise(Err.Number, Err.Source, Err.Description)
  End With
End Sub

'############################
'# RAW METHODS / PROPERTIES #
'############################

'Call a function in the VTable of the object at a specified offset
'@param VTableOffset                         - The offset of the method to call. IUnknown::QueryInterface=0; IUnknown::AddRef=1; IUnknown::Release=2; IDispatch::Invoke=6
'@param ReturnType                           - Return value of function, typically Long (HResult) for COM Object calls
'@param FunctionParameters as Array<Variant> - Arguments to send to function.
'@returns                                    - Return value of function
'@throws {...} "DispCallFunc - Unknown error occurred."
'@example ```vb
'  Dim pITypeInfo As IUnknown
'  Dim hResult As Long: hResult = com.CallVT(EIUnknown.QueryInterface, vbLong, VarPtr(tGUID.Data1), VarPtr(pITypeInfo))
'  If hResult <> S_OK Then Err_Raise hResult, "InterfaceInfo", "stdCOM::InterfaceInfo"
'```
Public Function CallVT(ByVal VTableOffset As Long, ByVal ReturnType As VbVarType, ParamArray FunctionParameters() As Variant) As Variant
  With stdError.getSentry("stdCOM#CallVT", "VTableOffset", VTableOffset, "ReturnType", ReturnType)
    On Error GoTo stdErrorWrapper_ErrorOccurred
    
        'Create array from params
        Dim vParam() As Variant: vParam = FunctionParameters
        Dim iParamCount As Long: iParamCount = UBound(vParam) - LBound(vParam) + 1
        
        'Create array of types and pointers to vars, for function call
        #If VBA7 Then
          Dim vPtr() As LongPtr
        #Else
          Dim vPtr() As Long
        #End If
        Dim vType() As Integer
    
        'Populate array of pointers to params, and array of types for DispCallFunc
        If iParamCount = 0 Then
          ReDim vType(0 To 0)
          ReDim vPtr(0 To 0)
        Else
          ReDim vType(0 To iParamCount - 1)
          ReDim vPtr(0 To iParamCount - 1)
        
          Dim lIdx As Long
          For lIdx = 0 To iParamCount - 1
            vType(lIdx) = VarType(vParam(lIdx))
            vPtr(lIdx) = VarPtr(vParam(lIdx))
          Next
        End If
        
        'Call function
        Dim hResult As Long, vv as variant
        hResult = DispCallFunc(This.ObjPtr, VTableOffset * PTRSIZE, CC_STDCALL, ReturnType, iParamCount, VarPtr(vType(0)), VarPtr(vPtr(0)), vv)
        
        If hResult < 0 Then
            Err_Raise hResult, "DispCallFunc", "DispCallFunc - Unknown error occurred."
        End If
    
    Exit Function
    stdErrorWrapper_ErrorOccurred:
      Call Err_Raise(Err.Number, Err.Source, Err.Description)
  End With
End Function

'*************
'* PROTECTED *
'*************
'Initialise from object's IUnknown
'@protected
'@param obj - Object to create raw COM object from
Friend Sub protInitFromObject(ByVal obj As IUnknown)
  With stdError.getSentry("stdCOM#protInitFromObject", "obj", obj)
    On Error GoTo stdErrorWrapper_ErrorOccurred
    
      This.ObjPtr = ObjPtr(obj)
      Set This.Meta = obj
    
    Exit Sub
    stdErrorWrapper_ErrorOccurred:
      Call Err_Raise(Err.Number, Err.Source, Err.Description)
  End With
End Sub

'Initialise from pointer to object
'@protected
'@param ptr - Pointer to object
'@param bAddRef - Whether to call `AddRef` on the object
Friend Sub protInitFromPtr(ByVal ptr As LongPtr, Optional ByVal bAddRef As Boolean = True)
  With stdError.getSentry("stdCOM#protInitFromPtr", "ptr", ptr, "bAddRef", bAddRef)
    On Error GoTo stdErrorWrapper_ErrorOccurred
    
      This.ObjPtr = ptr
      if bAddRef then Call unkAddRef
    
    Exit Sub
    stdErrorWrapper_ErrorOccurred:
      Call Err_Raise(Err.Number, Err.Source, Err.Description)
  End With
End Sub

'
'@destructor
Private Sub Class_Terminate()
  With stdError.getSentry("stdCOM#Class_Terminate")
    On Error GoTo stdErrorWrapper_ErrorOccurred
    
      'Revoke active objects
      If This.RegisteredOLEInstance > 0 Then Call RevokeActiveObjectEx(Object(), This.RegisteredOLEInstance)
      If This.RegisteredTimerOLEInstance > 0 Then Call RevokeActiveObjectEx(Me, This.RegisteredTimerOLEInstance)
      
      'Call unknown release (prevent memory leaks)
      If This.Meta Is Nothing Then Call unkRelease
    
    Exit Sub
    stdErrorWrapper_ErrorOccurred:
      Call Err_Raise(Err.Number, Err.Source, Err.Description)
  End With
End Sub

'Register an object in the ROT
'@param obj         - Object to register to ROT
'@param OLEInstance - ROT Cookie. This variable will be populated with data.
'@param sCLSID      - CLSID if required. If this arg isn't provided, a ProgID must be provided.
'@param ProgID      - ProgID if required. If this arg isn't provided, a CLSID must be provided.
Private Sub RegisterActiveObjectEx(obj As IUnknown, ByRef OLEInstance As Long, Optional ByVal sCLSID As String = "", Optional ByVal ProgID As String = "")
  With stdError.getSentry("stdCOM#RegisterActiveObjectEx", "obj", obj, "OLEInstance", OLEInstance, "sCLSID", sCLSID, "ProgID", ProgID)
    On Error GoTo stdErrorWrapper_ErrorOccurred
    
        Const ACTIVEOBJECT_WEAK = 1
    
        'Get clsid whether it be from CLSID string or ProgID
        Dim clsid As GUID, result As Long
        If ProgID <> "" Then
            result = CLSIDFromProgID(StrPtr(ProgID), clsid)
            If result <> S_OK Then
              Select Case Hex(result)
                Case "800401F3" 'CO_E_CLASSSTRING
                  Err_Raise 1, "", "The registered CLSID for the ProgID '" & ProgID & "' is invalid"
                Case "80040151" 'REGDB_E_WRITEREGDB
                  Err_Raise 1, "", "An error occurred writing the CLSID to the registry. See Remarks https://docs.microsoft.com/en-us/windows/win32/api/combaseapi/nf-combaseapi-clsidfromprogid."
              End Select
            End If
        ElseIf sCLSID <> "" Then
            result = CLSIDFromString(StrPtr(sCLSID), clsid)
            If result <> S_OK Then
              Select Case Hex(result)
                Case "800401F3" 'CO_E_CLASSSTRING
                  Err_Raise 1, "", "The CLSID was incorrectly formatted."
                Case "80040154" 'REGDB_E_CLASSNOTREG
                  Err_Raise 1, "", "The CLSID corresponding to the class string was not found in the registry."
                Case "80040150" 'REGDB_E_READREGDB
                  Err_Raise 1, "", "The registry could not be opened for reading."
                  
              End Select
            End If
        Else
            Err_Raise 7, "No CLSID or ProgId"
        End If
        
        'Attempt to register object to ROT
        If RegisterActiveObject32(obj, clsid, ACTIVEOBJECT_WEAK, OLEInstance) <> S_OK Then Err_Raise Err.LastDllError, "Object couldn't be registered"
    
    Exit Sub
    stdErrorWrapper_ErrorOccurred:
      Call Err_Raise(Err.Number, Err.Source, Err.Description)
  End With
End Sub

'Revoke an object in the ROT
'@param obj         - Object to revoke from ROT
'@param OLEInstance - ROT Cookie. This variable will be populated with data.
Private Sub RevokeActiveObjectEx(obj As IUnknown, ByRef OLEInstance As Long)
  With stdError.getSentry("stdCOM#RevokeActiveObjectEx", "obj", obj, "OLEInstance", OLEInstance)
    On Error GoTo stdErrorWrapper_ErrorOccurred
    
        'Remove instance from ROT
        If OLEInstance <> 0 Then
          If RevokeActiveObject32(OLEInstance, 0) <> 0 Then
            Debug.Print "Could not revoke?"
          End If
        End If
        
        'Disconnect any remote process connections being maintained on behalf of the active object pointer.
        If CoDisconnectObject(obj, 0) <> 0 Then Debug.Print "Couldn't disconnect object " & TypeName(obj)
    
    Exit Sub
    stdErrorWrapper_ErrorOccurred:
      Call Err_Raise(Err.Number, Err.Source, Err.Description)
  End With
End Sub

'Obtain a new GUID
'@returns - GUID as string
Private Function getGUID() As String
  With stdError.getSentry("stdCOM#getGUID")
    On Error GoTo stdErrorWrapper_ErrorOccurred
    
      getGUID = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx"
      getGUID = Replace(getGUID, "y", Hex(Rnd() And &H3 Or &H8))
      Dim i As Long: For i = 1 To 30
        getGUID = Replace(getGUID, "x", Hex$(CLng(Rnd() * 15.9999)), 1, 1)
      Next
    
    Exit Function
    stdErrorWrapper_ErrorOccurred:
      Call Err_Raise(Err.Number, Err.Source, Err.Description)
  End With
End Function

'Map between EKnownInterfaces and Interface IIDs
'@param iIID - Known interface to query for
'@returns - IID as string
Private Function KnownIID(ByVal iIID As EKnownInterfaces) As String
  With stdError.getSentry("stdCOM#KnownIID", "iIID", iIID)
    On Error GoTo stdErrorWrapper_ErrorOccurred
    
      Select Case iIID
        Case IUnknown:                KnownIID = "00000000-0000-0000-C000-000000000046"
        Case IDispatch:               KnownIID = "00020400-0000-0000-C000-000000000046"
        Case ITypeInfo:               KnownIID = "00020401-0000-0000-C000-000000000046"
        Case ITypeLib:                KnownIID = "00020402-0000-0000-C000-000000000046"
        Case ITypeComp:               KnownIID = "00020403-0000-0000-C000-000000000046"
        Case IEnumVARIANT:            KnownIID = "00020404-0000-0000-C000-000000000046"
        'Note sure if these are going to be useful,
        'but I found the IIDs and IIDs are generally hard to find
        'therefore, I'm providing them here
        Case ICreateTypeInfo:         KnownIID = "00020405-0000-0000-C000-000000000046"
        Case ICreateTypeLib:          KnownIID = "00020406-0000-0000-C000-000000000046"
        Case IClassFactory:           KnownIID = "00000001-0000-0000-C000-000000000046"
        Case IMalloc:                 KnownIID = "00000002-0000-0000-C000-000000000046"
        Case IMarshal:                KnownIID = "00000003-0000-0000-C000-000000000046"
        Case IRpcChannel:             KnownIID = "00000004-0000-0000-C000-000000000046"
        Case IRpcStub:                KnownIID = "00000005-0000-0000-C000-000000000046"
        Case IRpcProxy:               KnownIID = "00000007-0000-0000-C000-000000000046"
        Case IPSFactory:              KnownIID = "00000009-0000-0000-C000-000000000046"
        Case ILockBytes:              KnownIID = "0000000A-0000-0000-C000-000000000046"
        Case IStorage:                KnownIID = "0000000B-0000-0000-C000-000000000046"
        Case IStream:                 KnownIID = "0000000C-0000-0000-C000-000000000046"
        Case IEnumSTATSTG:            KnownIID = "0000000D-0000-0000-C000-000000000046"
        Case IBindCtx:                KnownIID = "0000000E-0000-0000-C000-000000000046"
        Case IMoniker:                KnownIID = "0000000F-0000-0000-C000-000000000046"
        Case IRunningObjectTable:     KnownIID = "00000010-0000-0000-C000-000000000046"
        Case IRootStorage:            KnownIID = "00000012-0000-0000-C000-000000000046"
        Case IMessageFilter:          KnownIID = "00000016-0000-0000-C000-000000000046"
        Case IStdMarshalInfo:         KnownIID = "00000018-0000-0000-C000-000000000046"
        Case IExternalConnection:     KnownIID = "00000019-0000-0000-C000-000000000046"
        Case IEnumUnknown:            KnownIID = "00000100-0000-0000-C000-000000000046"
        Case IEnumString:             KnownIID = "00000101-0000-0000-C000-000000000046"
        Case IEnumMoniker:            KnownIID = "00000102-0000-0000-C000-000000000046"
        Case IEnumFORMATETC:          KnownIID = "00000103-0000-0000-C000-000000000046"
        Case IEnumOLEVERB:            KnownIID = "00000104-0000-0000-C000-000000000046"
        Case IEnumSTATDATA:           KnownIID = "00000105-0000-0000-C000-000000000046"
        Case IPersistStream:          KnownIID = "00000109-0000-0000-C000-000000000046"
        Case IPersistStorage:         KnownIID = "0000010A-0000-0000-C000-000000000046"
        Case IPersistFile:            KnownIID = "0000010B-0000-0000-C000-000000000046"
        Case IPersist:                KnownIID = "0000010C-0000-0000-C000-000000000046"
        Case IViewObject:             KnownIID = "0000010D-0000-0000-C000-000000000046"
        Case IDataObject:             KnownIID = "0000010E-0000-0000-C000-000000000046"
        Case IAdviseSink:             KnownIID = "0000010F-0000-0000-C000-000000000046"
        Case IDataAdviseHolder:       KnownIID = "00000110-0000-0000-C000-000000000046"
        Case IOleAdviseHolder:        KnownIID = "00000111-0000-0000-C000-000000000046"
        Case IOleObject:              KnownIID = "00000112-0000-0000-C000-000000000046"
        Case IOleInPlaceObject:       KnownIID = "00000113-0000-0000-C000-000000000046"
        Case IOleWindow:              KnownIID = "00000114-0000-0000-C000-000000000046"
        Case IOleInPlaceUIWindow:     KnownIID = "00000115-0000-0000-C000-000000000046"
        Case IOleInPlaceFrame:        KnownIID = "00000116-0000-0000-C000-000000000046"
        Case IOleInPlaceActiveObject: KnownIID = "00000117-0000-0000-C000-000000000046"
        Case IOleClientSite:          KnownIID = "00000118-0000-0000-C000-000000000046"
        Case IOleInPlaceSite:         KnownIID = "00000119-0000-0000-C000-000000000046"
        Case IParseDisplayName:       KnownIID = "0000011A-0000-0000-C000-000000000046"
        Case IOleContainer:           KnownIID = "0000011B-0000-0000-C000-000000000046"
        Case IOleItemContainer:       KnownIID = "0000011C-0000-0000-C000-000000000046"
        Case IOleLink:                KnownIID = "0000011D-0000-0000-C000-000000000046"
        Case IOleCache:               KnownIID = "0000011E-0000-0000-C000-000000000046"
        Case IDropSource:             KnownIID = "00000121-0000-0000-C000-000000000046"
        Case IDropTarget:             KnownIID = "00000122-0000-0000-C000-000000000046"
        Case IDebugStream:            KnownIID = "00000124-0000-0000-C000-000000000046"
        Case IAdviseSink2:            KnownIID = "00000125-0000-0000-C000-000000000046"
        Case IRunnableObject:         KnownIID = "00000126-0000-0000-C000-000000000046"
        Case IViewObject2:            KnownIID = "00000127-0000-0000-C000-000000000046"
        Case IOleCache2:              KnownIID = "00000128-0000-0000-C000-000000000046"
        Case IOleCacheControl:        KnownIID = "00000129-0000-0000-C000-000000000046"
        Case IInspectable:            KnownIID = "af86e2e0-b12d-4c6a-9c5a-d7aa65101e90"
      End Select
      KnownIID = "{" & KnownIID & "}"
    
    Exit Function
    stdErrorWrapper_ErrorOccurred:
      Call Err_Raise(Err.Number, Err.Source, Err.Description)
  End With
End Function

'Deref pointer to string helper
'@param ptr - Pointer to string
'@returns - String
#If VBA7 Then
Private Function GetStrFromPtrW(ByVal ptr As LongPtr) As String
#Else
    Private Function GetStrFromPtrW(ByVal ptr As Long) As String
#End If
  With stdError.getSentry("stdCOM#GetStrFromPtrW", "ptr", ptr)
    On Error GoTo stdErrorWrapper_ErrorOccurred
    
        SysReAllocString VarPtr(GetStrFromPtrW), ptr
    
    Exit Function
    stdErrorWrapper_ErrorOccurred:
      Call Err_Raise(Err.Number, Err.Source, Err.Description)
  End With
End Function


'Deref pointer to IUnknown helper
'@param memAddress - Pointer to IUnknown
'@returns - IUnknown
'@devNote DO NOT RETURN `result`
#If VBA7 Then
Private Function Deref(ByVal memAddress As LongPtr) As IUnknown
#Else
  Private Function Deref(ByVal memAddress As Long) As IUnknown
#End If
  With stdError.getSentry("stdCOM#Deref", "memAddress", memAddress)
    On Error GoTo stdErrorWrapper_ErrorOccurred
    
      Dim result As IUnknown
      CopyMemory result, ByVal VarPtr(memAddress), LenB(memAddress)
      Set Deref = result                             'Set and add ref
      ZeroMemory result, LenB(memAddress)
    
    Exit Function
    stdErrorWrapper_ErrorOccurred:
      Call Err_Raise(Err.Number, Err.Source, Err.Description)
  End With
End Function

'IDEA: for ProgID based registration
'  RegisterProgID("...")
'  RevokeProgID()
'AHK Source
'===================
'RegisterIDs(CLSID, APPID)
'{
'  RegWrite, REG_SZ, HKCU, Software\Classes\%APPID%,, %APPID%
'  RegWrite, REG_SZ, HKCU, Software\Classes\%APPID%\CLSID,, %CLSID%
'  RegWrite, REG_SZ, HKCU, Software\Classes\CLSID\%CLSID%,, %APPID%
'}
'
'RevokeIDs(CLSID, APPID)
'{
'  RegDelete, HKCU, Software\Classes\%APPID%
'  RegDelete, HKCU, Software\Classes\CLSID\%CLSID%
'}




Private Sub Err_Raise(ByVal number as Long, Optional ByVal source as string = "", Optional ByVal description as string = "")
  Call stdError.Raise(description)
End Sub
